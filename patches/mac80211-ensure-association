Bottom: d6ed4493ba22cd5342588c344fd9cc404f934396
Top:    98f6f88af0a944a1b73ff98699078c3cc6093054
Author: Ben Greear <greearb@candelatech.com>
Date:   2015-10-14 11:22:46 -0700

mac80211: ensure association req uses configured ratemask.

When sending the association request, pay attention to the
legacy rates configured by the user, and do not advertise support
for any that are not configured.

This makes the assoc request packet look more correct when
making modern hardware act like a /b mode station, for instance.

Signed-off-by: Ben Greear <greearb@candelatech.com>


---

diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h
index 47ba428..f0efa0f0 100644
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -377,7 +377,7 @@ struct ieee80211_mgd_auth_data {
 
 struct ieee80211_mgd_assoc_data {
 	struct cfg80211_bss *bss;
-	const u8 *supp_rates;
+	u8 supp_rates[IEEE80211_MAX_SUPP_RATES];
 
 	unsigned long timeout;
 	int tries;
diff --git a/net/mac80211/mlme.c b/net/mac80211/mlme.c
index 7aaac1a..aa4284d 100644
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@ -628,6 +628,8 @@ static void ieee80211_send_assoc(struct ieee80211_sub_if_data *sdata)
 						     assoc_data->supp_rates_len,
 						     &rates);
 	} else {
+		u32 msk = sdata->cfg_advert_bitrate_mask.control[chan->band].legacy;
+
 		/*
 		 * In case AP not provide any supported rates information
 		 * before association, we send information element(s) with
@@ -638,6 +640,9 @@ static void ieee80211_send_assoc(struct ieee80211_sub_if_data *sdata)
 			if ((rate_flags & sband->bitrates[i].flags)
 			    != rate_flags)
 				continue;
+			if (sdata->cfg_advert_bitrate_mask_set &&
+			    (!(msk & (1 << i))))
+				continue;
 			rates |= BIT(i);
 			rates_len++;
 		}
@@ -4715,8 +4720,48 @@ int ieee80211_mgd_assoc(struct ieee80211_sub_if_data *sdata,
 		sdata->smps_mode = ifmgd->req_smps;
 
 	assoc_data->capability = req->bss->capability;
-	assoc_data->supp_rates = bss->supp_rates;
-	assoc_data->supp_rates_len = bss->supp_rates_len;
+	if (sdata->cfg_advert_bitrate_mask_set) {
+		int band = req->bss->channel->band;
+		u32 msk = sdata->cfg_advert_bitrate_mask.control[band].legacy;
+		u8 all_rates[12] = { 2, 4, 11, 22,
+				     12, 18, 24, 36, 48, 72, 96, 108 };
+		int i;
+		int q = 0;
+
+		/* Skip CCK rates for 5Ghz band */
+		if (band == NL80211_BAND_5GHZ)
+			msk = msk << 4;
+
+#if 0
+		pr_err("mgt-assoc, band: %d msk: 0x%x  bss-rates-len: %d\n",
+		       band, msk, (int)(bss->supp_rates_len));
+		for (i = 0; i < bss->supp_rates_len; i++) {
+			pr_err("bss rate[%d] = %d (0x%x)\n",
+			       i, bss->supp_rates[i], bss->supp_rates[i]);
+		}
+#endif
+		for (i = 0; i < 12; i++) {
+			int j;
+
+			if (!(msk & (1 << i)))
+				break;
+
+			for (j = 0; j < bss->supp_rates_len; j++) {
+				/* Mask out the 'basic-rate' flag, 0x80 */
+				if ((bss->supp_rates[j] & 0x7f) == all_rates[i]) {
+					assoc_data->supp_rates[q] =
+						bss->supp_rates[j];
+					q++;
+					break;
+				}
+			}
+		}
+		assoc_data->supp_rates_len = q;
+	} else {
+		memcpy(assoc_data->supp_rates, bss->supp_rates,
+		       bss->supp_rates_len);
+		assoc_data->supp_rates_len = bss->supp_rates_len;
+	}
 
 	rcu_read_lock();
 	ht_ie = ieee80211_bss_get_ie(req->bss, WLAN_EID_HT_OPERATION);
