Bottom: 77db3ee007ad71a48c45c76bb04030a293bcc7a9
Top:    36849e9c7761f50c509b2e1330a7d39367cc544e
Author: Ben Greear <greearb@candelatech.com>
Date:   2014-03-24 14:02:32 -0700

wireless: Print error logs for EINVAL scan failures.

There is no other easy way to tell why scans fail with
EINVAL since there are so many different errors that
return the same error code.

Signed-off-by: Ben Greear <greearb@candelatech.com>


---

diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index d759901..424ce82 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -5824,8 +5824,11 @@ static int validate_scan_freqs(struct nlattr *freqs)
 		 */
 		nla_for_each_nested(attr2, freqs, tmp2)
 			if (attr1 != attr2 &&
-			    nla_get_u32(attr1) == nla_get_u32(attr2))
+			    nla_get_u32(attr1) == nla_get_u32(attr2)) {
+				pr_err("scan:  Duplicate freq requested: %d\n",
+				       nla_get_u32(attr1));
 				return 0;
+			}
 	}
 
 	return n_channels;
@@ -5945,8 +5948,10 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
 	int err, tmp, n_ssids = 0, n_channels, i;
 	size_t ie_len;
 
-	if (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))
+	if (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE])) {
+		pr_err("scan:  Invalid ATTR_IE\n");
 		return -EINVAL;
+	}
 
 	wiphy = &rdev->wiphy;
 
@@ -5962,6 +5967,7 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
 		n_channels = validate_scan_freqs(
 				info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]);
 		if (!n_channels) {
+			pr_err("scan:  validate_scan_freqs failed, duplicate freq?\n");
 			err = -EINVAL;
 			goto unlock;
 		}
@@ -5974,6 +5980,8 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
 			n_ssids++;
 
 	if (n_ssids > wiphy->max_scan_ssids) {
+		pr_err("scan:  too many ssids, req: %d  supports: %d\n",
+		       n_ssids, wiphy->max_scan_ssids);
 		err = -EINVAL;
 		goto unlock;
 	}
@@ -5984,6 +5992,8 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
 		ie_len = 0;
 
 	if (ie_len > wiphy->max_scan_ie_len) {
+		pr_err("scan: ie-len too large: %zd  max: %d\n",
+		       ie_len, wiphy->max_scan_ie_len);
 		err = -EINVAL;
 		goto unlock;
 	}
@@ -6016,6 +6026,8 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
 			chan = ieee80211_get_channel(wiphy, nla_get_u32(attr));
 
 			if (!chan) {
+				pr_err("scan:  Channel %d is not supported.\n",
+				       nla_get_u32(attr));
 				err = -EINVAL;
 				goto out_free;
 			}
@@ -6050,6 +6062,7 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
 	}
 
 	if (!i) {
+		pr_err("scan:  No scannable channels found.\n");
 		err = -EINVAL;
 		goto out_free;
 	}
@@ -6060,6 +6073,8 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
 	if (n_ssids) {
 		nla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) {
 			if (nla_len(attr) > IEEE80211_MAX_SSID_LEN) {
+				pr_err("scan: ssid-len too large: %d  max: %d\n",
+				       nla_len(attr), IEEE80211_MAX_SSID_LEN);
 				err = -EINVAL;
 				goto out_free;
 			}
@@ -6088,6 +6103,8 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
 			enum nl80211_band band = nla_type(attr);
 
 			if (band < 0 || band >= NUM_NL80211_BANDS) {
+				pr_err("scan:  band %d out of range, num-bands: %d\n",
+				       band, IEEE80211_NUM_BANDS);
 				err = -EINVAL;
 				goto out_free;
 			}
