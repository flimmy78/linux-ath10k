Bottom: 057177a6def2a78a4bed0ab329f2d3dca17cefa9
Top:    5dd55bd528eddef0317d511bfda14dcf268cc6e9
Author: Ben Greear <greearb@candelatech.com>
Date:   2014-03-24 14:02:32 -0700

wireless: Print error logs for EINVAL scan failures.

There is no other easy way to tell why scans fail with
EINVAL since there are so many different errors that
return the same error code.

Signed-off-by: Ben Greear <greearb@candelatech.com>


---

diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index d759901..e3a7427 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -5824,8 +5824,11 @@ static int validate_scan_freqs(struct nlattr *freqs)
 		 */
 		nla_for_each_nested(attr2, freqs, tmp2)
 			if (attr1 != attr2 &&
-			    nla_get_u32(attr1) == nla_get_u32(attr2))
+			    nla_get_u32(attr1) == nla_get_u32(attr2)) {
+				pr_err("scan:  Duplicate freq requested: %d\n",
+				       nla_get_u32(attr1));
 				return 0;
+			}
 	}
 
 	return n_channels;
@@ -5945,8 +5948,10 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
 	int err, tmp, n_ssids = 0, n_channels, i;
 	size_t ie_len;
 
-	if (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))
+	if (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE])) {
+		pr_err("scan:  Invalid ATTR_IE\n");
 		return -EINVAL;
+	}
 
 	wiphy = &rdev->wiphy;
 
@@ -5962,6 +5967,7 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
 		n_channels = validate_scan_freqs(
 				info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]);
 		if (!n_channels) {
+			pr_err("scan:  validate_scan_freqs failed, duplicate freq?\n");
 			err = -EINVAL;
 			goto unlock;
 		}
@@ -5974,6 +5980,8 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
 			n_ssids++;
 
 	if (n_ssids > wiphy->max_scan_ssids) {
+		pr_err("scan:  too many ssids, req: %d  supports: %d\n",
+		       n_ssids, wiphy->max_scan_ssids);
 		err = -EINVAL;
 		goto unlock;
 	}
@@ -5984,6 +5992,8 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
 		ie_len = 0;
 
 	if (ie_len > wiphy->max_scan_ie_len) {
+		pr_err("scan: ie-len too large: %zd  max: %d\n",
+		       ie_len, wiphy->max_scan_ie_len);
 		err = -EINVAL;
 		goto unlock;
 	}
@@ -6016,6 +6026,8 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
 			chan = ieee80211_get_channel(wiphy, nla_get_u32(attr));
 
 			if (!chan) {
+				pr_err("scan:  Channel %d is not supported.\n",
+				       nla_get_u32(attr));
 				err = -EINVAL;
 				goto out_free;
 			}
@@ -6050,6 +6062,7 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
 	}
 
 	if (!i) {
+		pr_err("scan:  No scannable channels found.\n");
 		err = -EINVAL;
 		goto out_free;
 	}
@@ -6060,6 +6073,8 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
 	if (n_ssids) {
 		nla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) {
 			if (nla_len(attr) > IEEE80211_MAX_SSID_LEN) {
+				pr_err("scan: ssid-len too large: %d  max: %d\n",
+				       nla_len(attr), IEEE80211_MAX_SSID_LEN);
 				err = -EINVAL;
 				goto out_free;
 			}
@@ -6088,6 +6103,8 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
 			enum nl80211_band band = nla_type(attr);
 
 			if (band < 0 || band >= NUM_NL80211_BANDS) {
+				pr_err("scan:  band %d out of range, num-bands: %d\n",
+				       band, NUM_NL80211_BANDS);
 				err = -EINVAL;
 				goto out_free;
 			}
