Bottom: 48f2fdc5c3344d9ac0339e94aa1ef4818989e302
Top:    b6b89a7c837b7330f8cd340c75d1746ad265f3d4
Author: Ben Greear <greearb@candelatech.com>
Date:   2013-02-06 09:08:30 -0800

vlan: tx-busy sched backoff support.

Signed-off-by: Ben Greear <greearb@candelatech.com>


---

diff --git a/drivers/net/macvlan.c b/drivers/net/macvlan.c
index cb01023..d1a140c 100644
--- a/drivers/net/macvlan.c
+++ b/drivers/net/macvlan.c
@@ -494,7 +494,7 @@ static int macvlan_queue_xmit(struct sk_buff *skb, struct net_device *dev)
 
 xmit_world:
 	skb->dev = vlan->lowerdev;
-	return dev_queue_xmit(skb);
+	return try_dev_queue_xmit(skb, 1);
 }
 
 static inline netdev_tx_t macvlan_netpoll_send_skb(struct macvlan_dev *vlan, struct sk_buff *skb)
@@ -533,6 +533,11 @@ static netdev_tx_t macvlan_start_xmit(struct sk_buff *skb,
 		pcpu_stats->tx_packets++;
 		pcpu_stats->tx_bytes += len;
 		u64_stats_update_end(&pcpu_stats->syncp);
+	} else if (ret == NET_XMIT_BUSY) {
+		/* Calling code should retry, skb was NOT freed. */
+		/* sort of a collision, at least */
+		this_cpu_inc(vlan->pcpu_stats->collisions);
+		return NETDEV_TX_BUSY;
 	} else {
 		this_cpu_inc(vlan->pcpu_stats->tx_dropped);
 	}
@@ -839,7 +844,7 @@ static struct rtnl_link_stats64 *macvlan_dev_get_stats64(struct net_device *dev,
 	if (vlan->pcpu_stats) {
 		struct vlan_pcpu_stats *p;
 		u64 rx_packets, rx_bytes, rx_multicast, tx_packets, tx_bytes;
-		u32 rx_errors = 0, tx_dropped = 0;
+		u32 rx_errors = 0, tx_dropped = 0, collisions = 0;
 		unsigned int start;
 		int i;
 
@@ -864,10 +869,12 @@ static struct rtnl_link_stats64 *macvlan_dev_get_stats64(struct net_device *dev,
 			 */
 			rx_errors	+= p->rx_errors;
 			tx_dropped	+= p->tx_dropped;
+			collisions	+= p->collisions;
 		}
 		stats->rx_errors	= rx_errors;
 		stats->rx_dropped	= rx_errors;
 		stats->tx_dropped	= tx_dropped;
+		stats->collisions	= collisions;
 	}
 	return stats;
 }
diff --git a/net/8021q/vlan_dev.c b/net/8021q/vlan_dev.c
index 86ae75b..1b0d28e 100644
--- a/net/8021q/vlan_dev.c
+++ b/net/8021q/vlan_dev.c
@@ -106,9 +106,15 @@ static netdev_tx_t vlan_dev_hard_start_xmit(struct sk_buff *skb,
 {
 	struct vlan_dev_priv *vlan = vlan_dev_priv(dev);
 	struct vlan_ethhdr *veth = (struct vlan_ethhdr *)(skb->data);
+	struct sk_buff *oskb = skb;
 	unsigned int len;
 	int ret;
 
+	ret = -ENOMEM;
+	skb = skb_share_check(skb, GFP_ATOMIC);
+	if (skb == NULL)
+		goto err;
+
 	/* Handle non-VLAN frames if they are sent to us, for example by DHCP.
 	 *
 	 * NOTE: THIS ASSUMES DIX ETHERNET, SPECIFICALLY NOT SUPPORTING
@@ -127,7 +133,7 @@ static netdev_tx_t vlan_dev_hard_start_xmit(struct sk_buff *skb,
 	if (unlikely(netpoll_tx_running(dev)))
 		return vlan_netpoll_send_skb(vlan, skb);
 
-	ret = dev_queue_xmit(skb);
+	ret = try_dev_queue_xmit(skb, oskb == skb);
 
 	if (likely(ret == NET_XMIT_SUCCESS || ret == NET_XMIT_CN)) {
 		struct vlan_pcpu_stats *stats;
@@ -137,7 +143,13 @@ static netdev_tx_t vlan_dev_hard_start_xmit(struct sk_buff *skb,
 		stats->tx_packets++;
 		stats->tx_bytes += len;
 		u64_stats_update_end(&stats->syncp);
+	} else if (ret == NET_XMIT_BUSY) {
+		/* Calling code should retry, skb was NOT freed. */
+		/* sort of a collision, at least */
+		this_cpu_inc(vlan_dev_priv(dev)->vlan_pcpu_stats->collisions);
+		return NETDEV_TX_BUSY;
 	} else {
+err:
 		this_cpu_inc(vlan->vlan_pcpu_stats->tx_dropped);
 	}
 
@@ -672,7 +684,7 @@ static int vlan_ethtool_get_ts_info(struct net_device *dev,
 static struct rtnl_link_stats64 *vlan_dev_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)
 {
 	struct vlan_pcpu_stats *p;
-	u32 rx_errors = 0, tx_dropped = 0;
+	u32 rx_errors = 0, tx_dropped = 0, collisions = 0;
 	int i;
 
 	for_each_possible_cpu(i) {
@@ -697,10 +709,11 @@ static struct rtnl_link_stats64 *vlan_dev_get_stats64(struct net_device *dev, st
 		/* rx_errors & tx_dropped are u32 */
 		rx_errors	+= p->rx_errors;
 		tx_dropped	+= p->tx_dropped;
+		collisions	+= p->collisions;
 	}
 	stats->rx_errors  = rx_errors;
 	stats->tx_dropped = tx_dropped;
-
+	stats->collisions = collisions;
 	return stats;
 }
