Bottom: 476f77178a9f864364194590ec3fdb58864696f8
Top:    0ff00a10dd75b83c8f0b4626ca61893356ff5480
Author: Ben Greear <greearb@candelatech.com>
Date:   2016-04-20 13:50:03 -0700

ath10k: Use non-static if-limits, if-comb.

This lets us customize it per radio if we so desire.  Good when
used with the 'fwcfg' file logic.

Signed-off-by: Ben Greear <greearb@candelatech.com>


---

diff --git a/drivers/net/wireless/ath/ath10k/core.c b/drivers/net/wireless/ath/ath10k/core.c
index dcf9948..229a6e6 100644
--- a/drivers/net/wireless/ath/ath10k/core.c
+++ b/drivers/net/wireless/ath/ath10k/core.c
@@ -2498,6 +2498,16 @@ int ath10k_core_register(struct ath10k *ar, u32 chip_id)
 }
 EXPORT_SYMBOL(ath10k_core_register);
 
+void ath10k_core_free_limits(struct ath10k* ar)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(ar->if_comb); i++) {
+		kfree(ar->if_comb[i].limits);
+	}
+	memset(&ar->if_comb, 0, sizeof(ar->if_comb));
+}
+EXPORT_SYMBOL(ath10k_core_free_limits);
+
 void ath10k_core_unregister(struct ath10k *ar)
 {
 	cancel_work_sync(&ar->register_work);
@@ -2522,6 +2532,8 @@ void ath10k_core_unregister(struct ath10k *ar)
 	ath10k_core_free_firmware_files(ar);
 	ath10k_core_free_board_files(ar);
 
+	ath10k_core_free_limits(ar);
+
 	ath10k_debug_unregister(ar);
 }
 EXPORT_SYMBOL(ath10k_core_unregister);
diff --git a/drivers/net/wireless/ath/ath10k/core.h b/drivers/net/wireless/ath/ath10k/core.h
index ab2eeaf..4b4941a 100644
--- a/drivers/net/wireless/ath/ath10k/core.h
+++ b/drivers/net/wireless/ath/ath10k/core.h
@@ -797,6 +797,8 @@ struct ath10k {
 	struct device *dev;
 	u8 mac_addr[ETH_ALEN];
 
+	struct ieee80211_iface_combination if_comb[8];
+
 	enum ath10k_hw_rev hw_rev;
 	u16 dev_id;
 	bool fw_powerup_failed; /* If true, might take reboot to recover. */
@@ -1141,5 +1143,6 @@ int ath10k_wait_for_suspend(struct ath10k *ar, u32 suspend_opt);
 void ath10k_core_stop(struct ath10k *ar);
 int ath10k_core_register(struct ath10k *ar, u32 chip_id);
 void ath10k_core_unregister(struct ath10k *ar);
+void ath10k_core_free_limits(struct ath10k* ar);
 
 #endif /* _CORE_H_ */
diff --git a/drivers/net/wireless/ath/ath10k/mac.c b/drivers/net/wireless/ath/ath10k/mac.c
index e98fe14..0898422 100644
--- a/drivers/net/wireless/ath/ath10k/mac.c
+++ b/drivers/net/wireless/ath/ath10k/mac.c
@@ -696,8 +696,11 @@ static int ath10k_peer_create(struct ath10k *ar,
 	list_for_each_entry(arvif, &ar->arvifs, list)
 		num_peers++;
 
-	if (num_peers >= ar->max_num_peers)
+	if (num_peers >= ar->max_num_peers) {
+		ath10k_warn(ar, "failed to create peer %pM for vdev %d, too-many-peers (ar->num_peers: %d  num_peers: %d  max_peers: %d)\n",
+			    sta->addr, vdev_id, ar->num_peers, num_peers, ar->max_num_peers);
 		return -ENOBUFS;
+	}
 
 	ret = ath10k_wmi_peer_create(ar, vdev_id, addr, peer_type);
 	if (ret) {
@@ -8400,6 +8403,28 @@ struct ath10k_vif *ath10k_get_arvif(struct ath10k *ar, u32 vdev_id)
 	return arvif_iter.arvif;
 }
 
+int ath10k_copy_comb(struct ath10k* ar, struct ieee80211_iface_combination* comb,
+		     int array_len)
+{
+	int i;
+	int ln;
+
+	/* Clean out any existing combinations. */
+	ath10k_core_free_limits(ar);
+
+	memcpy(&ar->if_comb, ath10k_if_comb, sizeof(*comb) * array_len);
+	for (i = 0; i<array_len; i++) {
+		ln = comb->n_limits * sizeof(*comb->limits);
+		ar->if_comb[i].limits = kzalloc(ln, GFP_KERNEL);
+		if (!ar->if_comb[i].limits)
+			return -ENOMEM;
+		memcpy(ar->if_comb[i].limits, comb->limits, ln);
+	}
+
+	ar->hw->wiphy->iface_combinations = ar->if_comb;
+	ar->hw->wiphy->n_iface_combinations = array_len;
+}
+
 int ath10k_mac_register(struct ath10k *ar)
 {
 	static const u32 cipher_suites[] = {
@@ -8559,37 +8584,27 @@ int ath10k_mac_register(struct ath10k *ar)
 
 	switch (ar->running_fw->fw_file.wmi_op_version) {
 	case ATH10K_FW_WMI_OP_VERSION_MAIN:
-		ar->hw->wiphy->iface_combinations = ath10k_if_comb;
-		ar->hw->wiphy->n_iface_combinations =
-			ARRAY_SIZE(ath10k_if_comb);
+		ath10k_copy_comb(ar, ath10k_if_comb, ARRAY_SIZE(ath10k_if_comb));
 		ar->hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_ADHOC);
 		break;
 	case ATH10K_FW_WMI_OP_VERSION_TLV:
 		if (test_bit(WMI_SERVICE_ADAPTIVE_OCS, ar->wmi.svc_map)) {
-			ar->hw->wiphy->iface_combinations =
-				ath10k_tlv_qcs_if_comb;
-			ar->hw->wiphy->n_iface_combinations =
-				ARRAY_SIZE(ath10k_tlv_qcs_if_comb);
+			ath10k_copy_comb(ar, ath10k_tlv_qcs_if_comb,
+					 ARRAY_SIZE(ath10k_tlv_qcs_if_comb));
 		} else {
-			ar->hw->wiphy->iface_combinations = ath10k_tlv_if_comb;
-			ar->hw->wiphy->n_iface_combinations =
-				ARRAY_SIZE(ath10k_tlv_if_comb);
+			ath10k_copy_comb(ar, ath10k_tlv_if_comb,
+					 ARRAY_SIZE(ath10k_tlv_if_comb));
 		}
 		ar->hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_ADHOC);
 		break;
 	case ATH10K_FW_WMI_OP_VERSION_10_1:
 		if (test_bit(ATH10K_FW_FEATURE_WMI_10X_CT,
 			     ar->normal_mode_fw.fw_file.fw_features)) {
-			ar->hw->wiphy->iface_combinations = ath10k_10x_ct_if_comb;
-			ath10k_10x_ct_if_comb[0].limits[0].max =
-				ar->max_num_vdevs;
-			ath10k_10x_ct_if_comb[0].max_interfaces =
-				ar->max_num_vdevs;
-
-			ar->hw->wiphy->iface_combinations =
-				ath10k_10x_ct_if_comb;
-			ar->hw->wiphy->n_iface_combinations =
-				ARRAY_SIZE(ath10k_10x_ct_if_comb);
+			ath10k_copy_comb(ar, ath10k_10x_ct_if_comb,
+					 ARRAY_SIZE(ath10k_10x_ct_if_comb));
+
+			ar->if_comb[0].limits[0].max = ar->max_num_vdevs;
+			ar->if_comb[0].max_interfaces = ar->max_num_vdevs;
 			ar->hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_ADHOC);
 
 			/* CT firmware can do tx-sw-crypt if properly configured */
@@ -8598,24 +8613,20 @@ int ath10k_mac_register(struct ath10k *ar)
 			    ath10k_modparam_nohwcrypt)
 				__clear_bit(IEEE80211_HW_SW_CRYPTO_CONTROL, ar->hw->flags);
 		} else {
-			ar->hw->wiphy->iface_combinations = ath10k_10x_if_comb;
-			ar->hw->wiphy->n_iface_combinations =
-				ARRAY_SIZE(ath10k_10x_if_comb);
+			ath10k_copy_comb(ar, ath10k_10x_if_comb,
+					 ARRAY_SIZE(ath10k_10x_if_comb));
 		}
 		break;
 	case ATH10K_FW_WMI_OP_VERSION_10_2:
 	case ATH10K_FW_WMI_OP_VERSION_10_2_4:
 		if (test_bit(ATH10K_FW_FEATURE_WMI_10X_CT,
 			     ar->running_fw->fw_file.fw_features)) {
-			ath10k_10x_ct_if_comb[0].limits[0].max =
-				ar->max_num_vdevs;
-			ath10k_10x_ct_if_comb[0].max_interfaces =
-				ar->max_num_vdevs;
-
-			ar->hw->wiphy->iface_combinations =
-				ath10k_10x_ct_if_comb;
-			ar->hw->wiphy->n_iface_combinations =
-				ARRAY_SIZE(ath10k_10x_ct_if_comb);
+			ath10k_copy_comb(ar, ath10k_10x_ct_if_comb,
+					 ARRAY_SIZE(ath10k_10x_ct_if_comb));
+
+			ar->if_comb[0].limits[0].max = ar->max_num_vdevs;
+			ar->if_comb[0].max_interfaces = ar->max_num_vdevs;
+
 			ar->hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_ADHOC);
 
 			/* CT firmware can do tx-sw-crypt if properly configured */
@@ -8624,25 +8635,21 @@ int ath10k_mac_register(struct ath10k *ar)
 			    ath10k_modparam_nohwcrypt)
 				__clear_bit(IEEE80211_HW_SW_CRYPTO_CONTROL, ar->hw->flags);
 		} else {
-			ar->hw->wiphy->iface_combinations = ath10k_10x_if_comb;
-			ar->hw->wiphy->n_iface_combinations =
-				ARRAY_SIZE(ath10k_10x_if_comb);
+			ath10k_copy_comb(ar, ath10k_10x_if_comb,
+					 ARRAY_SIZE(ath10k_10x_if_comb));
 		}
 		break;
 	case ATH10K_FW_WMI_OP_VERSION_10_4:
 		if (test_bit(ATH10K_FW_FEATURE_WMI_10X_CT,
 			     ar->running_fw->fw_file.fw_features)) {
-			ath10k_10_4_ct_if_comb[0].limits[0].max =
-				ar->max_num_vdevs;
-			ath10k_10_4_ct_if_comb[0].max_interfaces =
-				ar->max_num_vdevs;
-			if (ath10k_10_4_ct_if_comb[0].limits[1].max > ar->max_num_vdevs)
-				ath10k_10_4_ct_if_comb[0].limits[1].max = ar->max_num_vdevs;
-
-			ar->hw->wiphy->iface_combinations =
-				ath10k_10_4_ct_if_comb;
-			ar->hw->wiphy->n_iface_combinations =
-				ARRAY_SIZE(ath10k_10_4_ct_if_comb);
+			ath10k_copy_comb(ar, ath10k_10_4_ct_if_comb,
+					 ARRAY_SIZE(ath10k_10_4_ct_if_comb));
+			ar->if_comb[0].limits[0].max = ar->max_num_vdevs;
+			ar->if_comb[0].max_interfaces = ar->max_num_vdevs;
+
+			if (ar->if_comb[0].limits[1].max > ar->max_num_vdevs)
+				ar->if_comb[0].limits[1].max = ar->max_num_vdevs;
+
 			ar->hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_ADHOC);
 
 			/* CT firmware can do tx-sw-crypt if properly configured */
@@ -8651,9 +8658,8 @@ int ath10k_mac_register(struct ath10k *ar)
 			    ath10k_modparam_nohwcrypt)
 				__clear_bit(IEEE80211_HW_SW_CRYPTO_CONTROL, ar->hw->flags);
 		} else {
-			ar->hw->wiphy->iface_combinations = ath10k_10_4_if_comb;
-			ar->hw->wiphy->n_iface_combinations =
-				ARRAY_SIZE(ath10k_10_4_if_comb);
+			ath10k_copy_comb(ar, ath10k_10_4_if_comb,
+					 ARRAY_SIZE(ath10k_10_4_if_comb));
 		}
 		break;
 	case ATH10K_FW_WMI_OP_VERSION_UNSET:
