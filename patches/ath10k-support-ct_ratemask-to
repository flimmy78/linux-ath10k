Bottom: 5424a5bf8610845bae833d7dbe06759d590b3874
Top:    4fac28b155f6a2d2837f4e4bccadef0e32a2c166
Author: Ben Greear <greearb@candelatech.com>
Date:   2015-09-13 18:07:01 -0700

ath10k: Support CT_RATEMASK to allow using arbitrary selection of rates.

This logic lets you specific an exact set of rates that the firmware rate-ctrl
will use.  Could use it to disable /b rates, for instance.  Current patch
only supports filtering on the legacy rates.  Will add support for HT
and VHT soon.

Supported by CT firmware v15 and higher.

Signed-off-by: Ben Greear <greearb@candelatech.com>


---

diff --git a/drivers/net/wireless/ath/ath10k/core.h b/drivers/net/wireless/ath/ath10k/core.h
index 31c85fc..8eca308 100644
--- a/drivers/net/wireless/ath/ath10k/core.h
+++ b/drivers/net/wireless/ath/ath10k/core.h
@@ -612,6 +612,12 @@ enum ath10k_fw_features {
 	 * encryption (ie, commercial version of CT firmware) */
 	ATH10K_FW_FEATURE_CT_RXSWCRYPT = 32,
 
+	/* Firmware supports extended wmi_common_peer_assoc_complete_cmd that contains
+	 * an array of rate-disable masks.  This allows the host to have better control
+	 * over what rates the firmware will use.  CT Firmware only (v15 and higher)
+	 */
+	ATH10K_FW_FEATURE_CT_RATEMASK = 33,
+
 	/* keep last */
 	ATH10K_FW_FEATURE_COUNT,
 };
diff --git a/drivers/net/wireless/ath/ath10k/mac.c b/drivers/net/wireless/ath/ath10k/mac.c
index b536fb1..23d2c49 100644
--- a/drivers/net/wireless/ath/ath10k/mac.c
+++ b/drivers/net/wireless/ath/ath10k/mac.c
@@ -2166,6 +2166,87 @@ ath10k_peer_assoc_h_vht_masked(const u16 vht_mcs_mask[NL80211_VHT_NSS_MAX])
 	return true;
 }
 
+static void ath10k_set_rate_enabled(int rix, u8 *rt_array, int val) {
+	int idx = rix / 8;
+	int bit = rix - (idx * 8);
+	if (val) {
+		rt_array[idx] |= (1<<bit);
+	}
+	else {
+		rt_array[idx] &= ~(1<<bit);
+	}
+}
+
+static void ath10k_peer_assoc_h_rate_overrides(struct ath10k *ar,
+					       struct ieee80211_vif *vif,
+					       struct ieee80211_sta *sta,
+					       struct wmi_peer_assoc_complete_arg *arg)
+{
+	struct ath10k_vif *arvif = ath10k_vif_to_arvif(vif);
+	const struct ieee80211_supported_band *sband;
+	const struct ieee80211_rate *rates;
+	struct cfg80211_chan_def def;
+	enum ieee80211_band band;
+	u32 ratemask;
+	int i, j;
+
+	if (! test_bit(ATH10K_FW_FEATURE_CT_RATEMASK, ar->fw_features))
+		return;
+
+	lockdep_assert_held(&ar->conf_mutex);
+
+	if (WARN_ON(ath10k_mac_vif_chan(vif, &def)))
+		return;
+
+	sband = ar->hw->wiphy->bands[band];
+	ratemask = arvif->bitrate_mask.control[band].legacy;
+	rates = sband->bitrates;
+
+	ath10k_warn(ar, "band: %d  ratemask: 0x%x\n", band, ratemask);
+
+	arg->has_rate_overrides = true;
+
+	/* By default, do not actually over-ride anything */
+	memset(arg->rate_overrides, 0xff, sizeof(arg->rate_overrides));
+
+	/* Now, do legacy rates:  0-3 are CCK (/b), 4-11 are OFDM (/a/g)... */
+	for (i = 0; i<12; i++) {
+		ath10k_set_rate_enabled(i, arg->rate_overrides, 0);
+	}
+
+	for (i = 0; i < 32; i++, ratemask >>= 1, rates++) {
+		if (!(ratemask & 1))
+			continue;
+
+		for (j = 0; j < ath10k_g_rates_size; j++) {
+			if (ath10k_rates[j].bitrate == rates->bitrate) {
+				int hw_rix;
+				if (ath10k_mac_bitrate_is_cck(rates->bitrate)) {
+					hw_rix = rates->hw_value;
+				}
+				else {
+					/* ofdm rates start at rix 4 */
+					hw_rix = rates->hw_value + 4;
+				}
+				ath10k_warn(ar, "set-enabled, bitrate: %d  j: %d  hw-value: %d hw-rix: %d\n",
+					    rates->bitrate, j, rates->hw_value, hw_rix);
+				ath10k_set_rate_enabled(hw_rix, arg->rate_overrides, 1);
+			}
+		}
+	}
+
+	/* End of legacy-rates logic. */
+	/* TODO:  HT, VHT */
+
+	for (i = 0; i < sizeof(arg->rate_overrides); i++) {
+		if (arg->rate_overrides[i] != 0xFF) {
+			ath10k_warn(ar, "vif: %d rate-overrides[%d]: 0x%x\n",
+				    arvif->vdev_id, i, arg->rate_overrides[i]);
+		}
+	}
+}
+
+
 static void ath10k_peer_assoc_h_ht(struct ath10k *ar,
 				   struct ieee80211_vif *vif,
 				   struct ieee80211_sta *sta,
@@ -2580,6 +2661,8 @@ static int ath10k_peer_assoc_prepare(struct ath10k *ar,
 	ath10k_peer_assoc_h_qos(ar, vif, sta, arg);
 	ath10k_peer_assoc_h_phymode(ar, vif, sta, arg);
 
+	ath10k_peer_assoc_h_rate_overrides(ar, vif, sta, arg);
+
 	return 0;
 }
 
@@ -2718,6 +2801,17 @@ static void ath10k_bss_assoc(struct ieee80211_hw *hw,
 
 	rcu_read_unlock();
 
+	if (test_bit(ATH10K_FW_FEATURE_CT_RATEMASK, ar->fw_features)) {
+		/* Firmware may cache rate-ctrl logic in host RAM.  Before we can set it,
+		 * it must be DMA'd to firmware RAM.  CT Firmware offers this API to cause
+		 * firmware to request it.  It is a race either way, but this should make
+		 * it work more often.  Last argument is ignored by firmware.
+		 */
+		ath10k_wmi_peer_set_param(ar, arvif->vdev_id, ap_sta->addr,
+					  WMI_PEER_FETCH_RC, 0);
+		msleep(1);
+	}
+
 	ret = ath10k_wmi_peer_assoc(ar, &peer_arg);
 	if (ret) {
 		ath10k_warn(ar, "failed to run peer assoc for %pM vdev %i: %d\n",
@@ -2820,6 +2914,17 @@ static int ath10k_station_assoc(struct ath10k *ar,
 		return ret;
 	}
 
+	if (test_bit(ATH10K_FW_FEATURE_CT_RATEMASK, ar->fw_features)) {
+		/* Firmware may cache rate-ctrl logic in host RAM.  Before we can set it,
+		 * it must be DMA'd to firmware RAM.  CT Firmware offers this API to cause
+		 * firmware to request it.  It is a race either way, but this should make
+		 * it work more often.  Last argument is ignored by firmware.
+		 */
+		ath10k_wmi_peer_set_param(ar, arvif->vdev_id, sta->addr,
+					  WMI_PEER_FETCH_RC, 0);
+		msleep(1);
+	}
+
 	ret = ath10k_wmi_peer_assoc(ar, &peer_arg);
 	if (ret) {
 		ath10k_warn(ar, "failed to run peer assoc for STA %pM vdev %i: %d\n",
diff --git a/drivers/net/wireless/ath/ath10k/wmi.c b/drivers/net/wireless/ath/ath10k/wmi.c
index 6d229fb..b9cd219 100644
--- a/drivers/net/wireless/ath/ath10k/wmi.c
+++ b/drivers/net/wireless/ath/ath10k/wmi.c
@@ -6643,8 +6643,20 @@ ath10k_wmi_peer_assoc_fill(struct ath10k *ar, void *buf,
 			   const struct wmi_peer_assoc_complete_arg *arg)
 {
 	struct wmi_common_peer_assoc_complete_cmd *cmd = buf;
+	u32 vid = arg->vdev_id;
+	u32 ext_flags = 0;
+
+	if (test_bit(ATH10K_FW_FEATURE_CT_RATEMASK, ar->fw_features)) {
+		/* Add some CT firmware specific stuff */
+		vid |= (1<<31); /* ext field exists */
+		if (arg->has_rate_overrides) {
+			ext_flags |= PEER_ASSOC_EXT_USE_OVERRIDES;
+			memcpy(cmd->rate_overrides, arg->rate_overrides, sizeof(cmd->rate_overrides));
+		}
+		cmd->ext_flags= __cpu_to_le32(ext_flags);
+	}
 
-	cmd->vdev_id            = __cpu_to_le32(arg->vdev_id);
+	cmd->vdev_id            = __cpu_to_le32(vid);
 	cmd->peer_new_assoc     = __cpu_to_le32(arg->peer_reassoc ? 0 : 1);
 	cmd->peer_associd       = __cpu_to_le32(arg->peer_aid);
 	cmd->peer_flags         = __cpu_to_le32(arg->peer_flags);
diff --git a/drivers/net/wireless/ath/ath10k/wmi.h b/drivers/net/wireless/ath/ath10k/wmi.h
index 51eca32..b2c312d 100644
--- a/drivers/net/wireless/ath/ath10k/wmi.h
+++ b/drivers/net/wireless/ath/ath10k/wmi.h
@@ -5832,6 +5832,11 @@ enum wmi_peer_param {
 	WMI_PEER_NSS        = 0x5,
 	WMI_PEER_USE_4ADDR  = 0x6,
 	WMI_PEER_DUMMY_VAR  = 0xff, /* dummy parameter for STA PS workaround */
+	WMI_PEER_FETCH_RC   = 0x10 /* Fetch rate-ctrl cache from host via DMA
+				    * Call this before setting rate-ctrl logic so that
+				    * firmware will have the firmware data in it's cache.
+				    * It is racy, but better than nothing.
+				    */
 };
 
 struct wmi_peer_set_param_cmd {
@@ -5993,6 +5998,8 @@ enum wmi_10_2_peer_flags {
 
 struct wmi_common_peer_assoc_complete_cmd {
 	struct wmi_mac_addr peer_macaddr;
+#define WMI_ASSOC_FLG_EXT (1<<31) /* Extended info is defined, CT firmware ver 15+ only,
+				   * packed into vdev_id */
 	__le32 vdev_id;
 	__le32 peer_new_assoc; /* 1=assoc, 0=reassoc */
 	__le32 peer_associd; /* 16 LSBs */
@@ -6009,6 +6016,16 @@ struct wmi_common_peer_assoc_complete_cmd {
 	__le32 peer_vht_caps;
 	__le32 peer_phymode;
 	struct wmi_vht_rate_set peer_vht_rates;
+
+	/* CT firmware ver 15+ only */
+#define PEER_ASSOC_EXT_USE_OVERRIDES (1<<0)
+	__le32 ext_flags;
+	u8 rate_overrides[20]; /* There are 150 rates...this holds 160, and keeps
+				* things 32-bit aligned.  If rate_overrides_set is 1,
+				* any rate NOT specified in rate_overrides will be
+				* disabled.
+				*/
+
 };
 
 struct wmi_main_peer_assoc_complete_cmd {
@@ -6056,6 +6073,10 @@ struct wmi_peer_assoc_complete_arg {
 	u32 peer_vht_caps;
 	enum wmi_phy_mode peer_phymode;
 	struct wmi_vht_rate_set_arg peer_vht_rates;
+
+	/* CT firmware only (beta-15 and higher ) */
+	bool has_rate_overrides;
+	u8 rate_overrides[20];
 };
 
 struct wmi_peer_add_wds_entry_cmd {
