Bottom: e1227c93b02aebc3660ce071261239281aec2e48
Top:    d8206695fd370bb3f3ede1249dc0d827e6803953
Author: Ben Greear <greearb@candelatech.com>
Date:   2016-03-09 17:29:05 -0800

ath10k: Fix CT ratemask handling for 4x4 NICs.

Several bugs:  First, have to extend each of the peer-assoc-complete
commands individually since otherwise we are out of sync with the
various firmware versions.

Second, don't hard-code rate-table as being 3x3.  Instead, use
the NSS reported by the firmware to know if 3x3 vs 4x4.

Third, VHT mcs entries are 16-bits, but only 10 of them
are used.

Signed-off-by: Ben Greear <greearb@candelatech.com>


---

diff --git a/drivers/net/wireless/ath/ath10k/mac.c b/drivers/net/wireless/ath/ath10k/mac.c
index dd64217..ed55688 100644
--- a/drivers/net/wireless/ath/ath10k/mac.c
+++ b/drivers/net/wireless/ath/ath10k/mac.c
@@ -2185,6 +2185,11 @@ ath10k_peer_assoc_h_vht_masked(const u16 vht_mcs_mask[NL80211_VHT_NSS_MAX])
 static void ath10k_set_rate_enabled(int rix, u8 *rt_array, int val) {
 	int idx = rix / 8;
 	int bit = rix - (idx * 8);
+
+	//pr_err(" rix: %d  idx: %d  bit: %d\n", rix, idx, bit);
+	if (WARN_ON_ONCE(idx >= RATE_OVERRIDES_COUNT))
+		return;
+
 	if (val) {
 		rt_array[idx] |= (1<<bit);
 	}
@@ -2207,6 +2212,7 @@ static void ath10k_peer_assoc_h_rate_overrides(struct ath10k *ar,
 	int i;
 	int j;
 	int hw_rix;
+	int hw_nss = ar->num_rf_chains;
 
 	if (! test_bit(ATH10K_FW_FEATURE_CT_RATEMASK,
 		       ar->running_fw->fw_file.fw_features))
@@ -2222,7 +2228,8 @@ static void ath10k_peer_assoc_h_rate_overrides(struct ath10k *ar,
 	ratemask = arvif->bitrate_mask.control[band].legacy;
 	rates = sband->bitrates;
 
-	ath10k_warn(ar, "band: %d  ratemask: 0x%x\n", band, ratemask);
+	ath10k_warn(ar, "band: %d  ratemask: 0x%x  hw-nss: %d\n",
+		    band, ratemask, hw_nss);
 
 	arg->has_rate_overrides = true;
 
@@ -2252,17 +2259,18 @@ static void ath10k_peer_assoc_h_rate_overrides(struct ath10k *ar,
 	 * using normal rate-set info as far as I can tell, so set both to the
 	 * same value.
 	 */
-	for (i = 0; i < 3; i++) {
+	for (i = 0; i < hw_nss; i++) {
 		unsigned int mcs = arvif->bitrate_mask.control[band].ht_mcs[i];
+		//ath10k_warn(ar, "ht-mcs [%i]: 0x%x\n", i, mcs);
 		for (j = 0; j<8; j++) {
 			if (mcs & (1<<j)) {
 				hw_rix = 12 + i * 8 + j;
 				ath10k_dbg(ar, ATH10K_DBG_MAC,
 					   "set-enabled, ht: hw-rix: %d, %d  i: %d j: %d\n",
-					   hw_rix, hw_rix + 3 * 8, i, j);
+					   hw_rix, hw_rix + hw_nss * 8, i, j);
 				ath10k_set_rate_enabled(hw_rix, arg->rate_overrides, 1);
 				/* Set HT40 rateset too */
-				ath10k_set_rate_enabled(hw_rix + 3 * 8, arg->rate_overrides, 1);
+				ath10k_set_rate_enabled(hw_rix + hw_nss * 8, arg->rate_overrides, 1);
 			}
 		}
 	}
@@ -2274,19 +2282,20 @@ static void ath10k_peer_assoc_h_rate_overrides(struct ath10k *ar,
 	 * using normal rate-set info as far as I can tell, so set all three to the
 	 * same value.
 	 */
-	for (i = 0; i < 3; i++) {
+	for (i = 0; i < hw_nss; i++) {
 		unsigned int mcs = arvif->bitrate_mask.control[band].vht_mcs[i];
-		for (j = 0; j<16; j++) {
+		//ath10k_warn(ar, "vht-mcs [%i]: 0x%x\n", i, mcs);
+		for (j = 0; j<10; j++) {
 			if (mcs & (1<<j)) {
-				hw_rix = 12 + 6 * 8 + i * 10 + j;
+				hw_rix = 12 + (hw_nss * 2) * 8 + i * 10 + j;
 				ath10k_dbg(ar, ATH10K_DBG_MAC,
 					   "set-enabled, vht: hw-rix: %d, %d, %d  i: %d j: %d\n",
-					   hw_rix, hw_rix + 3 * 10, hw_rix + 6 * 10, i, j);
+					   hw_rix, hw_rix + hw_nss * 10, hw_rix + hw_nss * 2 * 10, i, j);
 				ath10k_set_rate_enabled(hw_rix, arg->rate_overrides, 1);
 				/* Set HT40 rateset too */
-				ath10k_set_rate_enabled(hw_rix + 3 * 10, arg->rate_overrides, 1);
+				ath10k_set_rate_enabled(hw_rix + hw_nss * 10, arg->rate_overrides, 1);
 				/* Set HT80 rateset too */
-				ath10k_set_rate_enabled(hw_rix + 6 * 10, arg->rate_overrides, 1);
+				ath10k_set_rate_enabled(hw_rix + hw_nss * 2 * 10, arg->rate_overrides, 1);
 			}
 		}
 	}
diff --git a/drivers/net/wireless/ath/ath10k/wmi.c b/drivers/net/wireless/ath/ath10k/wmi.c
index 8038efc..ba0c23e 100644
--- a/drivers/net/wireless/ath/ath10k/wmi.c
+++ b/drivers/net/wireless/ath/ath10k/wmi.c
@@ -6758,10 +6758,39 @@ ath10k_wmi_peer_assoc_fill(struct ath10k *ar, void *buf,
 		/* Add some CT firmware specific stuff */
 		vid |= (1<<31); /* ext field exists */
 		if (arg->has_rate_overrides) {
+			int i;
+			int opver = ar->running_fw->fw_file.wmi_op_version;
 			ext_flags |= PEER_ASSOC_EXT_USE_OVERRIDES;
-			memcpy(cmd->rate_overrides, arg->rate_overrides, sizeof(cmd->rate_overrides));
+			ext_flags |= PEER_ASSOC_EXT_LEN_32;
+
+			ath10k_warn(ar, "overrides: len %d\n", (int)(sizeof(arg->rate_overrides)));
+			for (i = 0; i<sizeof(arg->rate_overrides); i++) {
+				ath10k_warn(ar, "[%i] 0x%x\n",
+					    i, arg->rate_overrides[i]);
+			}
+			if (opver == ATH10K_FW_WMI_OP_VERSION_10_4) {
+				struct wmi_10_4_peer_assoc_complete_cmd_ct *c = (void*)cmd;
+				memcpy(c->overrides.rate_overrides, arg->rate_overrides,
+				       sizeof(c->overrides.rate_overrides));
+				c->overrides.ext_flags = __cpu_to_le32(ext_flags);
+			}
+			else if ((opver == ATH10K_FW_WMI_OP_VERSION_10_2) ||
+				 (opver == ATH10K_FW_WMI_OP_VERSION_10_2_4)) {
+				struct wmi_10_2_peer_assoc_complete_cmd_ct *c = (void*)cmd;
+				memcpy(c->overrides.rate_overrides, arg->rate_overrides,
+				       sizeof(c->overrides.rate_overrides));
+				c->overrides.ext_flags = __cpu_to_le32(ext_flags);
+			}
+			else if (opver == ATH10K_FW_WMI_OP_VERSION_10_1) {
+				struct wmi_10_1_peer_assoc_complete_cmd_ct *c = (void*)cmd;
+				memcpy(c->overrides.rate_overrides, arg->rate_overrides,
+				       sizeof(c->overrides.rate_overrides));
+				c->overrides.ext_flags = __cpu_to_le32(ext_flags);
+			}
+			else {
+				WARN_ON_ONCE(1);
+			}
 		}
-		cmd->ext_flags= __cpu_to_le32(ext_flags);
 	}
 
 	cmd->vdev_id            = __cpu_to_le32(vid);
@@ -6888,7 +6917,7 @@ static struct sk_buff *
 ath10k_wmi_10_1_op_gen_peer_assoc(struct ath10k *ar,
 				  const struct wmi_peer_assoc_complete_arg *arg)
 {
-	size_t len = sizeof(struct wmi_10_1_peer_assoc_complete_cmd);
+	size_t len = sizeof(struct wmi_10_1_peer_assoc_complete_cmd_ct);
 	struct sk_buff *skb;
 	int ret;
 
@@ -6914,7 +6943,7 @@ static struct sk_buff *
 ath10k_wmi_10_2_op_gen_peer_assoc(struct ath10k *ar,
 				  const struct wmi_peer_assoc_complete_arg *arg)
 {
-	size_t len = sizeof(struct wmi_10_2_peer_assoc_complete_cmd);
+	size_t len = sizeof(struct wmi_10_2_peer_assoc_complete_cmd_ct);
 	struct sk_buff *skb;
 	int ret;
 
@@ -6939,7 +6968,7 @@ static struct sk_buff *
 ath10k_wmi_10_4_op_gen_peer_assoc(struct ath10k *ar,
 				  const struct wmi_peer_assoc_complete_arg *arg)
 {
-	size_t len = sizeof(struct wmi_10_4_peer_assoc_complete_cmd);
+	size_t len = sizeof(struct wmi_10_4_peer_assoc_complete_cmd_ct);
 	struct sk_buff *skb;
 	int ret;
 
diff --git a/drivers/net/wireless/ath/ath10k/wmi.h b/drivers/net/wireless/ath/ath10k/wmi.h
index 9cc82ca..3476164f 100644
--- a/drivers/net/wireless/ath/ath10k/wmi.h
+++ b/drivers/net/wireless/ath/ath10k/wmi.h
@@ -6030,16 +6030,6 @@ struct wmi_common_peer_assoc_complete_cmd {
 	__le32 peer_vht_caps;
 	__le32 peer_phymode;
 	struct wmi_vht_rate_set peer_vht_rates;
-
-	/* CT firmware ver 15+ only */
-#define PEER_ASSOC_EXT_USE_OVERRIDES (1<<0)
-	__le32 ext_flags;
-	u8 rate_overrides[20]; /* There are 150 rates...this holds 160, and keeps
-				* things 32-bit aligned.  If rate_overrides_set is 1,
-				* any rate NOT specified in rate_overrides will be
-				* disabled.
-				*/
-
 };
 
 struct wmi_main_peer_assoc_complete_cmd {
@@ -6054,6 +6044,26 @@ struct wmi_10_1_peer_assoc_complete_cmd {
 	struct wmi_common_peer_assoc_complete_cmd cmd;
 } __packed;
 
+struct wmi_ct_assoc_overrides {
+	/* CT firmware ver 15+ only */
+#define PEER_ASSOC_EXT_USE_OVERRIDES (1<<0)
+#define PEER_ASSOC_EXT_IGNORE_MCS_4_NSS_MASK (1<<1)
+#define PEER_ASSOC_EXT_LEN_32        (1<<2) /* Has 32-override bytes */
+	__le32 ext_flags;
+
+#define RATE_OVERRIDES_COUNT 32
+	/* Space for 256 rates.  If rate_overrides_set is 1,
+	 * any rate NOT specified in rate_overrides will be
+	 * disabled.
+	 */
+	u8 rate_overrides[RATE_OVERRIDES_COUNT];
+} __packed;
+
+struct wmi_10_1_peer_assoc_complete_cmd_ct {
+	struct wmi_10_1_peer_assoc_complete_cmd cmd;
+	struct wmi_ct_assoc_overrides overrides;
+} __packed;
+
 #define WMI_PEER_ASSOC_INFO0_MAX_MCS_IDX_LSB 0
 #define WMI_PEER_ASSOC_INFO0_MAX_MCS_IDX_MASK 0x0f
 #define WMI_PEER_ASSOC_INFO0_MAX_NSS_LSB 4
@@ -6064,11 +6074,21 @@ struct wmi_10_2_peer_assoc_complete_cmd {
 	__le32 info0; /* WMI_PEER_ASSOC_INFO0_ */
 } __packed;
 
+struct wmi_10_2_peer_assoc_complete_cmd_ct {
+	struct wmi_10_2_peer_assoc_complete_cmd cmd;
+	struct wmi_ct_assoc_overrides overrides;
+} __packed;
+
 struct wmi_10_4_peer_assoc_complete_cmd {
 	struct wmi_10_2_peer_assoc_complete_cmd cmd;
 	__le32 peer_bw_rxnss_override;
 } __packed;
 
+struct wmi_10_4_peer_assoc_complete_cmd_ct {
+	struct wmi_10_4_peer_assoc_complete_cmd cmd;
+	struct wmi_ct_assoc_overrides overrides;
+} __packed;
+
 struct wmi_peer_assoc_complete_arg {
 	u8 addr[ETH_ALEN];
 	u32 vdev_id;
@@ -6090,7 +6110,7 @@ struct wmi_peer_assoc_complete_arg {
 
 	/* CT firmware only (beta-15 and higher ) */
 	bool has_rate_overrides;
-	u8 rate_overrides[20];
+	u8 rate_overrides[RATE_OVERRIDES_COUNT];
 };
 
 struct wmi_peer_add_wds_entry_cmd {
