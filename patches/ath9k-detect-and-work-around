Bottom: 5c858a030ad42d88962ba9c04db7af930196a137
Top:    704ca3f8d7ff1b774e969813d8522a56e6ecea81
Author: Ben Greear <greearb@candelatech.com>
Date:   2014-08-11 13:36:23 -0700

ath9k: Detect and work-around tx-queue hang.

We see TX lockups on ar9380 NICs when running 32 stations
each with a 56kbps stream of MTU sized UDP packets.
We see lockups on the AP and also on the station, seems
random which hits first.

The test case further involves a programmable attenuator,
and the attenuation is taken from -30 to -85 signal level
in steps of 10db.  Each step runs for 1 minute before
increasing the attenuation.  The problem normally
shows up around signal level of -70 (noise is reported
as around -95).

When the lockup hits, it is typically on a single queue
(BE).  The symptom is that there is no obvious transmit
activity on that queue, the acq-depth and axq-ampdu-depth
are zero, the queue is stopped, and the pending-frames is
at or above the maximum allowed.  The VO queue continues
to function, and RX logic functions fine.

Just resetting the chip does not fix the problem:  The
pending-frames usually stays at max.  So, this patch also
adds hacks to force pending-frames to zero.  It also
quietens some warnings about pending-frame underruns
because sometimes, the tx status does appear many seconds
later.

Finally, the reset fixup code is logged at ath_err because
I think everyone should be aware of events like this.

We see the same problem with ath9k rate control and
minstrel-ht.  We have not tested other ath9k chipsets
in this manner.

Small numbers of high-speed stations do not hit this
problem, or at least not in our test cases.

Signed-off-by: Ben Greear <greearb@candelatech.com>


---

diff --git a/drivers/net/wireless/ath/ath9k/ath9k.h b/drivers/net/wireless/ath/ath9k/ath9k.h
index 93b3793..5791223 100644
--- a/drivers/net/wireless/ath/ath9k/ath9k.h
+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
@@ -164,8 +164,9 @@ struct ath_txq {
 	spinlock_t axq_lock;
 	u32 axq_depth;
 	u32 axq_ampdu_depth;
+	u8 axq_tx_inprogress;
 	bool stopped;
-	bool axq_tx_inprogress;
+	bool clear_pending_frames_on_flush;
 	struct list_head txq_fifo[ATH_TXFIFO_DEPTH];
 	u8 txq_headidx;
 	u8 txq_tailidx;
diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 5ad0fee..33505e7 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -40,20 +40,45 @@ void ath_tx_complete_poll_work(struct work_struct *work)
 
 		ath_txq_lock(sc, txq);
 		if (txq->axq_depth) {
-			if (txq->axq_tx_inprogress) {
+			if (txq->axq_tx_inprogress > 1) {
 				needreset = true;
+				ath_err(ath9k_hw_common(sc->sc_ah),
+                                        "tx hung, queue: %i axq-depth: %i, ampdu-depth: %i resetting the chip\n",
+                                        i, txq->axq_depth,
+                                        txq->axq_ampdu_depth);
 				ath_txq_unlock(sc, txq);
 				break;
 			} else {
-				txq->axq_tx_inprogress = true;
+				txq->axq_tx_inprogress++;
+			}
+		} else {
+			/* Check for software TX hang.  It seems
+			 * sometimes pending-frames is not properly
+			 * decremented, and the tx queue hangs.
+			 * Considered hung if:  axq-depth is zero,
+			 *  ampdu-depth is zero, queue-is-stopped,
+			 *  and we have pending frames.
+			 */
+			if (txq->stopped &&
+			    (txq->axq_ampdu_depth == 0) &&
+			    (txq->pending_frames > 0)) {
+				if (txq->axq_tx_inprogress > 1) {
+					ath_err(ath9k_hw_common(sc->sc_ah),
+						"soft tx hang: queue: %i pending-frames: %i, resetting chip\n",
+						i, txq->pending_frames);
+					needreset = true;
+					txq->clear_pending_frames_on_flush = true;
+					ath_txq_unlock(sc, txq);
+					break;
+				} else {
+					txq->axq_tx_inprogress++;
+				}
 			}
 		}
 		ath_txq_unlock(sc, txq);
 	}
 
 	if (needreset) {
-		ath_dbg(ath9k_hw_common(sc->sc_ah), RESET,
-			"tx hung, resetting the chip\n");
 		ath9k_queue_reset(sc, RESET_TYPE_TX_HANG);
 		return;
 	}
diff --git a/drivers/net/wireless/ath/ath9k/xmit.c b/drivers/net/wireless/ath/ath9k/xmit.c
index 8ddd604..92a18b1 100644
--- a/drivers/net/wireless/ath/ath9k/xmit.c
+++ b/drivers/net/wireless/ath/ath9k/xmit.c
@@ -152,9 +152,13 @@ static void ath_txq_skb_done(struct ath_softc *sc, struct ath_txq *txq,
 	if (q < 0)
 		return;
 
-	txq = sc->tx.txq_map[q];
-	if (WARN_ON(--txq->pending_frames < 0))
+	if (--txq->pending_frames < 0) {
+		struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+		if (net_ratelimit())
+			ath_err(common, "txq: %p had negative pending_frames, q: %i\n",
+				txq, q);
 		txq->pending_frames = 0;
+	}
 
 	if (txq->stopped &&
 	    txq->pending_frames < sc->tx.txq_max_pending[q]) {
@@ -669,7 +673,7 @@ static void ath_tx_process_buffer(struct ath_softc *sc, struct ath_txq *txq,
 
 	txok = !(ts->ts_status & ATH9K_TXERR_MASK);
 	flush = !!(ts->ts_status & ATH9K_TX_FLUSH);
-	txq->axq_tx_inprogress = false;
+	txq->axq_tx_inprogress = 0;
 
 	txq->axq_depth--;
 	if (bf_is_ampdu_not_probing(bf))
@@ -1745,7 +1749,7 @@ struct ath_txq *ath_txq_setup(struct ath_softc *sc, int qtype, int subtype)
 		spin_lock_init(&txq->axq_lock);
 		txq->axq_depth = 0;
 		txq->axq_ampdu_depth = 0;
-		txq->axq_tx_inprogress = false;
+		txq->axq_tx_inprogress = 0;
 		sc->tx.txqsetup |= 1<<axq_qnum;
 
 		txq->txq_headidx = txq->txq_tailidx = 0;
@@ -1846,9 +1850,18 @@ void ath_draintxq(struct ath_softc *sc, struct ath_txq *txq)
 	}
 
 	txq->axq_link = NULL;
-	txq->axq_tx_inprogress = false;
+	txq->axq_tx_inprogress = 0;
 	ath_drain_txq_list(sc, txq, &txq->axq_q);
 
+	if (txq->clear_pending_frames_on_flush && (txq->pending_frames != 0)) {
+		ath_err(ath9k_hw_common(sc->sc_ah),
+			"Pending frames still exist on txq: %i after drain: %i  axq-depth: %i  ampdu-depth: %i\n",
+			txq->mac80211_qnum, txq->pending_frames, txq->axq_depth,
+			txq->axq_ampdu_depth);
+		txq->pending_frames = 0;
+	}
+	txq->clear_pending_frames_on_flush = false;
+
 	ath_txq_unlock_complete(sc, txq);
 }
