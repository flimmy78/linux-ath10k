Bottom: d616b0a91b8c87d27d362e24645b4bad66d4c843
Top:    5424a5bf8610845bae833d7dbe06759d590b3874
Author: Ben Greear <greearb@candelatech.com>
Date:   2015-09-01 13:40:22 -0700

ath10k: Support override for noise-floor and min-cca-power thresholds.

This is only supported on CT firmware.  These settings will over-ride
defaults, including eeprom settings.

DO NOT USE unless you understand the consequences.

This patch was written to allow WLE900VX to pass ETSI
CCA Adaptivity testing.  Without this patch, a -70db
100% duty cycle signal was not enough to cause the NIC to stop transmitting
for a full 60 seconds.  This was on channel 13, in /b/g mode.
A -66 100% duty cycle did cause TX to stop.

Setting noise-floor to 4 db lower does appear to make it
pass the test with -70db noise source.

The API is a bit tricky, mainly to keep the driver patch
smaller.

See help:

[root@ct523-1ac-lr201408006507 lanforge]# cat /debug/ieee80211/wiphy2/ath10k/ct_special
BE WARNED:  You should understand the values before setting anything here.
You could put your NIC out of spec or maybe even break the hardware if you
put in bad values.

Value is u64, encoded thus:
id = t64 >> 32
val = t64 & 0xFFFFFFFF
id: 3 THRESH62_EXT (both bands use same value currently)
  value = val & 0xFF;
id: 4 CCA-Values, encoded as below:
  band = val >> 24;  //(0 5Ghz, 1 2.4Ghz)
  type = (val >> 16) & 0xFF; // 0-2 minCcaPwr[type], 3 noiseFloorThresh
         4 enable_minccapwr_thresh
  value = val & 0xFFFF;
    Unless otherwise specified, 0 means don't set.
    enable-minccapwr-thresh:  1 disabled, 2 enabled.

Example value to set noise-floor-threshold to 29, on 2.4Ghz band
for radio wiphy2:

echo 0x40103001d > /debug/ieee80211/wiphy2/ath10k/ct_special

Signed-off-by: Ben Greear <greearb@candelatech.com>


---

diff --git a/drivers/net/wireless/ath/ath10k/core.c b/drivers/net/wireless/ath/ath10k/core.c
index fc0ef31..5b1ea99 100644
--- a/drivers/net/wireless/ath/ath10k/core.c
+++ b/drivers/net/wireless/ath/ath10k/core.c
@@ -1698,6 +1698,7 @@ int ath10k_core_start(struct ath10k *ar, enum ath10k_firmware_mode mode,
 {
 	int status;
 	u32 val;
+	u32 i, band;
 
 	lockdep_assert_held(&ar->conf_mutex);
 
@@ -1880,11 +1881,25 @@ int ath10k_core_start(struct ath10k *ar, enum ath10k_firmware_mode mode,
 		goto err_hif_stop;
 
 	/* Apply user-supplied configuration changes. */
-	if (ar->ath10k_thresh62_ext) {
-		/* Don't worry about failures..not much we can do, and not worth failing init even
-		 * if this fails.
-		 */
-		ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_THRESH62_EXT, ar->ath10k_thresh62_ext);
+	/* Don't worry about failures..not much we can do, and not worth failing init even
+	 * if this fails.
+	 */
+	for (band = 0; band < 2; band++) {
+		u32 val;
+		for (i = 0; i<MIN_CCA_PWR_COUNT; i++) {
+			val = (band << 24) | (i << 16) | ar->eeprom_overrides.bands[band].minCcaPwrCT[i];
+			ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_NOISE_FLR_THRESH, val);
+		}
+
+		i = 4; /* enable-minccapwr-thresh type */
+		val = (band << 24) | (i << 16) | ar->eeprom_overrides.bands[band].enable_minccapwr_thresh;
+		ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_NOISE_FLR_THRESH, val);
+	}
+
+	/* TODO:  Should probably be per-band?? */
+	if (ar->eeprom_overrides.thresh62_ext) {
+		ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_THRESH62_EXT,
+					    ar->eeprom_overrides.thresh62_ext);
 	}
 
 	return 0;
diff --git a/drivers/net/wireless/ath/ath10k/core.h b/drivers/net/wireless/ath/ath10k/core.h
index 489f695..31c85fc 100644
--- a/drivers/net/wireless/ath/ath10k/core.h
+++ b/drivers/net/wireless/ath/ath10k/core.h
@@ -1002,7 +1002,20 @@ struct ath10k {
 	struct ath10k_thermal thermal;
 	struct ath10k_wow wow;
 
-	u8 ath10k_thresh62_ext; /* be sure to flush this to firmware after resets */
+	/* Index 0 is for 5Ghz, index 1 is for 2.4Ghz, CT firmware only. */
+	/* be sure to flush this to firmware after resets */
+	struct {
+		struct {
+#define MIN_CCA_PWR_COUNT 3
+			u16 minCcaPwrCT[MIN_CCA_PWR_COUNT]; /* 0 means don't-set */
+			u8 noiseFloorThresh; /* 0 means don't-set */
+			/* Have to set this to 2 before minCcaPwr settings will be active.
+			 * Values:  0  don't-set, 1 disable, 2 enable
+			 */
+			u8 enable_minccapwr_thresh;
+		} bands[2];
+		u8 thresh62_ext;
+	} eeprom_overrides;
 
 	/* must be last */
 	u8 drv_priv[0] __aligned(sizeof(void *));
diff --git a/drivers/net/wireless/ath/ath10k/debug.c b/drivers/net/wireless/ath/ath10k/debug.c
index 1625577..3a1ebd9 100644
--- a/drivers/net/wireless/ath/ath10k/debug.c
+++ b/drivers/net/wireless/ath/ath10k/debug.c
@@ -2607,15 +2607,15 @@ static ssize_t ath10k_write_thresh62_ext(struct file *file,
 					 size_t count, loff_t *ppos)
 {
 	struct ath10k *ar = file->private_data;
-	u8 enable;
+	u8 val;
 	int ret = 0;
 
-	if (kstrtou8_from_user(ubuf, count, 0, &enable))
+	if (kstrtou8_from_user(ubuf, count, 0, &val))
 		return -EINVAL;
 
 	mutex_lock(&ar->conf_mutex);
-	ar->ath10k_thresh62_ext = enable;
-	ret = ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_THRESH62_EXT, enable);
+	ar->eeprom_overrides.thresh62_ext = val;
+	ret = ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_THRESH62_EXT, val);
 	mutex_unlock(&ar->conf_mutex);
 
 	return ret ?: count;
@@ -2631,7 +2631,7 @@ static ssize_t ath10k_read_thresh62_ext(struct file *file,
 
 	mutex_lock(&ar->conf_mutex);
 	len = scnprintf(buf, sizeof(buf) - len, "%d\n",
-			ar->ath10k_thresh62_ext);
+			ar->eeprom_overrides.thresh62_ext);
 	mutex_unlock(&ar->conf_mutex);
 
 	return simple_read_from_buffer(ubuf, count, ppos, buf, len);
@@ -2643,6 +2643,83 @@ static const struct file_operations fops_thresh62_ext = {
 	.open = simple_open
 };
 
+static ssize_t ath10k_write_ct_special(struct file *file,
+				       const char __user *ubuf,
+				       size_t count, loff_t *ppos)
+{
+	struct ath10k *ar = file->private_data;
+	u64 tmp;
+	u32 id;
+	u32 val;
+	int ret = 0;
+
+	if (kstrtou64_from_user(ubuf, count, 0, &tmp))
+		return -EINVAL;
+
+	id = tmp >> 32;
+	val = tmp & 0xFFFFFFFF;
+
+	mutex_lock(&ar->conf_mutex);
+	if (id == SET_SPECIAL_ID_THRESH62_EXT) {
+		ar->eeprom_overrides.thresh62_ext = val;
+	}
+	else if (id == SET_SPECIAL_ID_NOISE_FLR_THRESH) {
+		u8 band = val >> 24;
+		u8 type = (val >> 16) & 0xFF;
+		if ((band > 2) || (type > CT_CCA_TYPE_MAX)) {
+			ret = -EINVAL;
+			goto unlock;
+		}
+		if (type <= CT_CCA_TYPE_MIN2)
+			ar->eeprom_overrides.bands[band].minCcaPwrCT[type] = val & 0xFFFF;
+		else if (type == CT_CCA_TYPE_NOISE_FLOOR)
+			ar->eeprom_overrides.bands[band].noiseFloorThresh = val & 0xFFFF;
+		else if (type == CT_CCA_TYPE_EN_MINCCAPWR)
+			ar->eeprom_overrides.bands[band].enable_minccapwr_thresh = val & 0xFFFF;
+	}
+	/* else, pass it through to firmware...but will not be stored locally, so
+	 * won't survive through firmware reboots, etc.
+	 */
+
+	/* Send it to the firmware. */
+	ret = ath10k_wmi_pdev_set_special(ar, id, val);
+unlock:
+	mutex_unlock(&ar->conf_mutex);
+
+	return ret ?: count;
+}
+
+static ssize_t ath10k_read_ct_special(struct file *file,
+				      char __user *user_buf,
+				      size_t count, loff_t *ppos)
+{
+	const char buf[] =
+		"BE WARNED:  You should understand the values before setting anything here.\n"
+		"You could put your NIC out of spec or maybe even break the hardware if you\n"
+		"put in bad values.\n\n"
+		"Value is u64, encoded thus:\n"
+		"id = t64 >> 32\n"
+		"val = t64 & 0xFFFFFFFF\n"
+		"id: 3 THRESH62_EXT (both bands use same value currently)\n"
+		"  value = val & 0xFF;\n"
+		"id: 4 CCA-Values, encoded as below:\n"
+		"  band = val >> 24;  //(0 5Ghz, 1 2.4Ghz)\n"
+		"  type = (val >> 16) & 0xFF; // 0-2 minCcaPwr[type], 3 noiseFloorThresh\n"
+		"         4 enable_minccapwr_thresh\n"
+		"  value = val & 0xFFFF;\n"
+		"    Unless otherwise specified, 0 means don't set.\n"
+		"    enable-minccapwr-thresh:  1 disabled, 2 enabled.\n\n";
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, strlen(buf));
+}
+
+static const struct file_operations fops_ct_special = {
+	.read = ath10k_read_ct_special,
+	.write = ath10k_write_ct_special,
+	.open = simple_open
+};
+
+
 static ssize_t ath10k_write_quiet_period(struct file *file,
 					 const char __user *ubuf,
 					 size_t count, loff_t *ppos)
@@ -2893,6 +2970,9 @@ int ath10k_debug_create(struct ath10k *ar)
 	debugfs_create_file("thresh62_ext", S_IRUGO | S_IWUSR,
 			    ar->debug.debugfs_phy, ar, &fops_thresh62_ext);
 
+	debugfs_create_file("ct_special", S_IRUGO | S_IWUSR,
+			    ar->debug.debugfs_phy, ar, &fops_ct_special);
+
 	return 0;
 }
 
diff --git a/drivers/net/wireless/ath/ath10k/wmi.h b/drivers/net/wireless/ath/ath10k/wmi.h
index 1beaca2..51eca32 100644
--- a/drivers/net/wireless/ath/ath10k/wmi.h
+++ b/drivers/net/wireless/ath/ath10k/wmi.h
@@ -6387,6 +6387,17 @@ struct wmi_pdev_set_special_cmd {
 				       * same register/field as: PHY_BB_EXT_CHAN_PWR_THR_1_THR_CCA_EXT40
 				       * this is an 8-bit value.
 				       */
+#define SET_SPECIAL_ID_NOISE_FLR_THRESH 4 /* Set some CCA related values in the eeprom struct.  Over-rides existing values.
+					   * BE CAREFUL!  This could put your system out of spec.  It can also put it in
+					   * spec when the eeprom values are dodgy.
+                                           * See debug.c, ath10k_read_ct_special for details.
+                                           */
+#define CT_CCA_TYPE_MIN0 0
+#define CT_CCA_TYPE_MIN1 1
+#define CT_CCA_TYPE_MIN2 2
+#define CT_CCA_TYPE_NOISE_FLOOR 3
+#define CT_CCA_TYPE_EN_MINCCAPWR 4
+#define CT_CCA_TYPE_MAX 4 /* change as more types are added */
 
     __le32 id;
     __le32 val;
