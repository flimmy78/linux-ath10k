Bottom: bdd751328653f9acc9353d8f80f48d12b0919e04
Top:    5701092f2b6d11f9a835883a51d0eb10c8799ea3
Author: Ben Greear <greearb@candelatech.com>
Date:   2013-05-09 11:56:22 -0700

mac80211: Limit number of pending skbs.

Current code will allow any number of pending skbs, and
this can OOM the system when used with something like
the pktgen tool (which may not back off properly if
queue is stopped).

Possibly this is just a bug in our version of pktgen,
but either way, it seems reasonable to add a limit
so that it is not possible to go OOM in this manner.

Signed-off-by: Ben Greear <greearb@candelatech.com>


---

diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c
index 2030443..5d8c936 100644
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -34,6 +34,17 @@
 #include "wpa.h"
 #include "wme.h"
 #include "rate.h"
+#include <linux/moduleparam.h>
+
+/*
+ * Maximum number of skbs that may be queued in a pending
+ * queue.  After that, packets will just be dropped.
+ */
+static int max_pending_qsize = 1000;
+module_param(max_pending_qsize, int, 0644);
+MODULE_PARM_DESC(max_pending_qsize,
+		 "Maximum number of skbs that may be queued in a pending queue.");
+
 
 /* misc utils */
 
@@ -1385,15 +1396,28 @@ static bool ieee80211_tx_frags(struct ieee80211_local *local,
 				 * later transmission from the tx-pending
 				 * tasklet when the queue is woken again.
 				 */
-				if (txpending)
+				bool do_free = false;
+				if (txpending) {
 					skb_queue_splice_init(skbs,
 							      &local->pending[q]);
-				else
-					skb_queue_splice_tail_init(skbs,
-								   &local->pending[q]);
+				} else {
+					u32 len = skb_queue_len(&local->pending[q]);
+					if (len >= max_pending_qsize) {
+						__skb_unlink(skb, skbs);
+						do_free = true;
+					} else {
+						skb_queue_splice_tail_init(skbs,
+									   &local->pending[q]);
+					}
+				}
 
 				spin_unlock_irqrestore(&local->queue_stop_reason_lock,
 						       flags);
+				if (do_free) {
+					dev_kfree_skb_any(skb);
+					/* TODO:  Add counter for this */
+				}
+
 				return false;
 			}
 		}
